#!/bin/sh

__usage () {
cat << EOH
$0 -i file [-o file]

$0 generates a Secret Santa list, making sure that no one in the same
team gifts each other (e.g. spouses), and that no one gifts themselves.

-i file:
  input file; default: none

Input: full participant description, one per line
# email            team    Full Name with spaces
  santa@cla.us     XMas    Santa Claus
  moviuro@popho.be noob    Moviuro

-o file:
  output file; default: out.${0##*/}
  this file will be overwritten if it exists

Output: pair information, one per line
# email_santa      Full Santee Name
  santa@cla.us     Moviuro
  moviuro@popho.be Santa Claus
EOH
}

while getopts ":hi:o:" _opt; do
  case "$_opt" in
    h) __usage ; exit ;;
    i) _in="$OPTARG" ;;
    o) _out="$OPTARG" ;;
    *) __usage >&2 ; exit 1 ;;
  esac
done

[ -z "$_out" ] && _out="out.${0##*/}"
: "${_in?requires an input file}"
_tmp="$(mktemp)"
__cleanup() {
  [ -e "$_tmp" ] && rm "$_tmp"
}
trap __cleanup INT TERM

printf '%s\n' "This might take a while." >&2

# Shuffle the input, read that line-by-line. If the current line has the same
# team as the previous one, it's not OK.
# The first and last line are the same to avoid dealing with start/end
# conditions
__check() {
  [ "$(wc -l < "$1")" -lt 2 ] && return 1
  _prev_team=""
  _ret=0
  while read -r _email _team _fullname; do
    case "$_team" in
      "$_prev_team") _ret=1; break;;
      *) _prev_team="$_team";;
    esac
  done < "$1"
  return "$_ret"
}

while ! __check "$_tmp"; do
  sort -R "$_in" > "$_tmp"
  head -n1 "$_tmp" >> "$_tmp"
done

while read -r _email _ _fullname; do
  if [ -n "$_prev_name" ]; then
    echo "$_email $_prev_name"
  fi
  _prev_name="$_fullname"
done < "$_tmp" > "$_out"

__cleanup
